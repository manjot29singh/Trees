import java.util.ArrayList;
public class l003gt{
    //GENERIC TREE
    public static class Node{
        int data=0;
        ArrayList<Node> childs = new ArrayList<>();
        Node(int data){
            this.data=data;
        }
    }
    public static int size(Node node){
    int sizee=0;
    for(Node child : node.childs){//for every child node in childs arraylist
        sizee= sizee + size(child); //size is equal to size + size(child);
    }
    return sizee + 1 ; //+1 for the node's size.
    }
    public static int height(Node node){
        int h = -1;
        for(Node child : node.childs){
            h = Math.max(h,height(child));
        }
        return h+1;
    }
    public static int maximum(Node node){
        int max= -(int)1e9;
        for(Node child : node.childs){
            max= Math.max(max,maximum(child));
        }
        return Math.max(max,node.data);
    }
     public static int minimum(Node node){
        int min = node.data;
        for(Node child : node.childs){
            min= Math.min(min,minimum(child));
        }
        return min;
    }
    public static boolean find(Node node,int data){//198:10
        boolean res = node.data== data;
        for(Node child : node.childs){
            res = res || find(child,data);
        }
        return res;
    }
    public static boolean roottonodepath(Node node,int data ,ArrayList<Node> list){
        boolean res = node.data == data;
        for(Node child : node.childs){
            res = res || roottonodepath(child,data,list);//if first condition fails then second will be checked.
        }
        if(res){
            list.add(node);
        }
        return res;
    }
    
     public static ArrayList<Integer> nodeToRootPath(Node node, int data) {//faith = ki sare child apne s lekr data tk ka path ek arraylist m daalkr return krdenge
        if (node.data == data) { //agr pehla hi child hi desired data ho
          ArrayList<Integer> path = new ArrayList<>();//make a new arraylist
          path.add(node.data);//add ur self and node.data
          return path;//return it
        }
    
        for (Node child : node.childs) {//otherwise wehn the first child is not the desired data go with a loop on evry child
          ArrayList<Integer> ptc = nodeToRootPath(child, data); //ptc= Pathtillchild call the recurssion till the first child of the root node and then if arraylist is not empty so add the node.data to it and return it.
          if (ptc.size() > 0) { //if ptc size is bigger then zero means it has only the path from root to node otherwise the other childs are are unable to return a filled arraylist .They returned a empty one.
            ptc.add(node.data);//if any child gives the filled arraylist it means that arraylist contains the nodetorootpath so just add the root.data into it and return it.
            return ptc;
          }
        }
    
        return new ArrayList<>();//if data is not prsent return an empty arraylist.
      }
    
    
    
    
    
}
